// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: definitions.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Xamarin.ExposureNotifications
{

	/// <summary>Holder for reflection information generated from definitions.proto</summary>
	public static partial class DefinitionsReflection
	{

		#region Descriptor
		/// <summary>File descriptor for definitions.proto</summary>
		public static pbr::FileDescriptor Descriptor
		{
			get { return descriptor; }
		}
		private static pbr::FileDescriptor descriptor;

		static DefinitionsReflection()
		{
			byte[] descriptorData = global::System.Convert.FromBase64String(
				string.Concat(
				  "ChFkZWZpbml0aW9ucy5wcm90byLRAQoaVGVtcG9yYXJ5RXhwb3N1cmVLZXlF",
				  "eHBvcnQSFwoPc3RhcnRfdGltZXN0YW1wGAEgASgGEhUKDWVuZF90aW1lc3Rh",
				  "bXAYAiABKAYSDgoGcmVnaW9uGAMgASgJEhEKCWJhdGNoX251bRgEIAEoBRIS",
				  "CgpiYXRjaF9zaXplGAUgASgFEicKD3NpZ25hdHVyZV9pbmZvcxgGIAMoCzIO",
				  "LlNpZ25hdHVyZUluZm8SIwoEa2V5cxgHIAMoCzIVLlRlbXBvcmFyeUV4cG9z",
				  "dXJlS2V5IpsBCg1TaWduYXR1cmVJbmZvEhUKDWFwcF9idW5kbGVfaWQYASAB",
				  "KAkSFwoPYW5kcm9pZF9wYWNrYWdlGAIgASgJEiAKGHZlcmlmaWNhdGlvbl9r",
				  "ZXlfdmVyc2lvbhgDIAEoCRIbChN2ZXJpZmljYXRpb25fa2V5X2lkGAQgASgJ",
				  "EhsKE3NpZ25hdHVyZV9hbGdvcml0aG0YBSABKAkijQEKFFRlbXBvcmFyeUV4",
				  "cG9zdXJlS2V5EhAKCGtleV9kYXRhGAEgASgMEh8KF3RyYW5zbWlzc2lvbl9y",
				  "aXNrX2xldmVsGAIgASgFEiUKHXJvbGxpbmdfc3RhcnRfaW50ZXJ2YWxfbnVt",
				  "YmVyGAMgASgFEhsKDnJvbGxpbmdfcGVyaW9kGAQgASgFOgMxNDQiNQoQVEVL",
				  "U2lnbmF0dXJlTGlzdBIhCgpzaWduYXR1cmVzGAEgAygLMg0uVEVLU2lnbmF0",
				  "dXJlInAKDFRFS1NpZ25hdHVyZRImCg5zaWduYXR1cmVfaW5mbxgBIAEoCzIO",
				  "LlNpZ25hdHVyZUluZm8SEQoJYmF0Y2hfbnVtGAIgASgFEhIKCmJhdGNoX3Np",
				  "emUYAyABKAUSEQoJc2lnbmF0dXJlGAQgASgMQiCqAh1YYW1hcmluLkV4cG9z",
				  "dXJlTm90aWZpY2F0aW9ucw=="));
			descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
				new pbr::FileDescriptor[] { },
				new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
			new pbr::GeneratedClrTypeInfo(typeof(global::Xamarin.ExposureNotifications.TemporaryExposureKeyExport), global::Xamarin.ExposureNotifications.TemporaryExposureKeyExport.Parser, new[]{ "StartTimestamp", "EndTimestamp", "Region", "BatchNum", "BatchSize", "SignatureInfos", "Keys" }, null, null, null, null),
			new pbr::GeneratedClrTypeInfo(typeof(global::Xamarin.ExposureNotifications.SignatureInfo), global::Xamarin.ExposureNotifications.SignatureInfo.Parser, new[]{ "AppBundleId", "AndroidPackage", "VerificationKeyVersion", "VerificationKeyId", "SignatureAlgorithm" }, null, null, null, null),
			new pbr::GeneratedClrTypeInfo(typeof(global::Xamarin.ExposureNotifications.TemporaryExposureKey), global::Xamarin.ExposureNotifications.TemporaryExposureKey.Parser, new[]{ "KeyData", "TransmissionRiskLevel", "RollingStartIntervalNumber", "RollingPeriod" }, null, null, null, null),
			new pbr::GeneratedClrTypeInfo(typeof(global::Xamarin.ExposureNotifications.TEKSignatureList), global::Xamarin.ExposureNotifications.TEKSignatureList.Parser, new[]{ "Signatures" }, null, null, null, null),
			new pbr::GeneratedClrTypeInfo(typeof(global::Xamarin.ExposureNotifications.TEKSignature), global::Xamarin.ExposureNotifications.TEKSignature.Parser, new[]{ "SignatureInfo", "BatchNum", "BatchSize", "Signature" }, null, null, null, null)
				}));
		}
		#endregion

	}
	#region Messages
	public sealed partial class TemporaryExposureKeyExport : pb::IMessage<TemporaryExposureKeyExport>
	{
		private static readonly pb::MessageParser<TemporaryExposureKeyExport> _parser = new pb::MessageParser<TemporaryExposureKeyExport>(() => new TemporaryExposureKeyExport());
		private pb::UnknownFieldSet _unknownFields;
		private int _hasBits0;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pb::MessageParser<TemporaryExposureKeyExport> Parser { get { return _parser; } }

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pbr::MessageDescriptor Descriptor
		{
			get { return global::Xamarin.ExposureNotifications.DefinitionsReflection.Descriptor.MessageTypes[0]; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		pbr::MessageDescriptor pb::IMessage.Descriptor
		{
			get { return Descriptor; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKeyExport()
		{
			OnConstruction();
		}

		partial void OnConstruction();

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKeyExport(TemporaryExposureKeyExport other) : this()
		{
			_hasBits0 = other._hasBits0;
			startTimestamp_ = other.startTimestamp_;
			endTimestamp_ = other.endTimestamp_;
			region_ = other.region_;
			batchNum_ = other.batchNum_;
			batchSize_ = other.batchSize_;
			signatureInfos_ = other.signatureInfos_.Clone();
			keys_ = other.keys_.Clone();
			_unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKeyExport Clone()
		{
			return new TemporaryExposureKeyExport(this);
		}

		/// <summary>Field number for the "start_timestamp" field.</summary>
		public const int StartTimestampFieldNumber = 1;
		private readonly static ulong StartTimestampDefaultValue = 0UL;

		private ulong startTimestamp_;
		/// <summary>
		/// Time window of keys in this batch based on arrival to server, in UTC seconds
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public ulong StartTimestamp
		{
			get { if ((_hasBits0 & 1) != 0) { return startTimestamp_; } else { return StartTimestampDefaultValue; } }
			set
			{
				_hasBits0 |= 1;
				startTimestamp_ = value;
			}
		}
		/// <summary>Gets whether the "start_timestamp" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasStartTimestamp
		{
			get { return (_hasBits0 & 1) != 0; }
		}
		/// <summary>Clears the value of the "start_timestamp" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearStartTimestamp()
		{
			_hasBits0 &= ~1;
		}

		/// <summary>Field number for the "end_timestamp" field.</summary>
		public const int EndTimestampFieldNumber = 2;
		private readonly static ulong EndTimestampDefaultValue = 0UL;

		private ulong endTimestamp_;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public ulong EndTimestamp
		{
			get { if ((_hasBits0 & 2) != 0) { return endTimestamp_; } else { return EndTimestampDefaultValue; } }
			set
			{
				_hasBits0 |= 2;
				endTimestamp_ = value;
			}
		}
		/// <summary>Gets whether the "end_timestamp" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasEndTimestamp
		{
			get { return (_hasBits0 & 2) != 0; }
		}
		/// <summary>Clears the value of the "end_timestamp" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearEndTimestamp()
		{
			_hasBits0 &= ~2;
		}

		/// <summary>Field number for the "region" field.</summary>
		public const int RegionFieldNumber = 3;
		private readonly static string RegionDefaultValue = "";

		private string region_;
		/// <summary>
		/// Region for which these keys came from (e.g., country)
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string Region
		{
			get { return region_ ?? RegionDefaultValue; }
			set
			{
				region_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "region" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasRegion
		{
			get { return region_ != null; }
		}
		/// <summary>Clears the value of the "region" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearRegion()
		{
			region_ = null;
		}

		/// <summary>Field number for the "batch_num" field.</summary>
		public const int BatchNumFieldNumber = 4;
		private readonly static int BatchNumDefaultValue = 0;

		private int batchNum_;
		/// <summary>
		/// E.g., File 2 in batch size of 10. Ordinal, 1-based numbering.
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int BatchNum
		{
			get { if ((_hasBits0 & 4) != 0) { return batchNum_; } else { return BatchNumDefaultValue; } }
			set
			{
				_hasBits0 |= 4;
				batchNum_ = value;
			}
		}
		/// <summary>Gets whether the "batch_num" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasBatchNum
		{
			get { return (_hasBits0 & 4) != 0; }
		}
		/// <summary>Clears the value of the "batch_num" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearBatchNum()
		{
			_hasBits0 &= ~4;
		}

		/// <summary>Field number for the "batch_size" field.</summary>
		public const int BatchSizeFieldNumber = 5;
		private readonly static int BatchSizeDefaultValue = 0;

		private int batchSize_;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int BatchSize
		{
			get { if ((_hasBits0 & 8) != 0) { return batchSize_; } else { return BatchSizeDefaultValue; } }
			set
			{
				_hasBits0 |= 8;
				batchSize_ = value;
			}
		}
		/// <summary>Gets whether the "batch_size" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasBatchSize
		{
			get { return (_hasBits0 & 8) != 0; }
		}
		/// <summary>Clears the value of the "batch_size" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearBatchSize()
		{
			_hasBits0 &= ~8;
		}

		/// <summary>Field number for the "signature_infos" field.</summary>
		public const int SignatureInfosFieldNumber = 6;
		private static readonly pb::FieldCodec<global::Xamarin.ExposureNotifications.SignatureInfo> _repeated_signatureInfos_codec
			= pb::FieldCodec.ForMessage(50, global::Xamarin.ExposureNotifications.SignatureInfo.Parser);
		private readonly pbc::RepeatedField<global::Xamarin.ExposureNotifications.SignatureInfo> signatureInfos_ = new pbc::RepeatedField<global::Xamarin.ExposureNotifications.SignatureInfo>();
		/// <summary>
		/// Information about associated signatures
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public pbc::RepeatedField<global::Xamarin.ExposureNotifications.SignatureInfo> SignatureInfos
		{
			get { return signatureInfos_; }
		}

		/// <summary>Field number for the "keys" field.</summary>
		public const int KeysFieldNumber = 7;
		private static readonly pb::FieldCodec<global::Xamarin.ExposureNotifications.TemporaryExposureKey> _repeated_keys_codec
			= pb::FieldCodec.ForMessage(58, global::Xamarin.ExposureNotifications.TemporaryExposureKey.Parser);
		private readonly pbc::RepeatedField<global::Xamarin.ExposureNotifications.TemporaryExposureKey> keys_ = new pbc::RepeatedField<global::Xamarin.ExposureNotifications.TemporaryExposureKey>();
		/// <summary>
		/// The TemporaryExposureKeys themselves
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public pbc::RepeatedField<global::Xamarin.ExposureNotifications.TemporaryExposureKey> Keys
		{
			get { return keys_; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override bool Equals(object other)
		{
			return Equals(other as TemporaryExposureKeyExport);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool Equals(TemporaryExposureKeyExport other)
		{
			if (ReferenceEquals(other, null))
			{
				return false;
			}
			if (ReferenceEquals(other, this))
			{
				return true;
			}
			if (StartTimestamp != other.StartTimestamp) return false;
			if (EndTimestamp != other.EndTimestamp) return false;
			if (Region != other.Region) return false;
			if (BatchNum != other.BatchNum) return false;
			if (BatchSize != other.BatchSize) return false;
			if (!signatureInfos_.Equals(other.signatureInfos_)) return false;
			if (!keys_.Equals(other.keys_)) return false;
			return Equals(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override int GetHashCode()
		{
			int hash = 1;
			if (HasStartTimestamp) hash ^= StartTimestamp.GetHashCode();
			if (HasEndTimestamp) hash ^= EndTimestamp.GetHashCode();
			if (HasRegion) hash ^= Region.GetHashCode();
			if (HasBatchNum) hash ^= BatchNum.GetHashCode();
			if (HasBatchSize) hash ^= BatchSize.GetHashCode();
			hash ^= signatureInfos_.GetHashCode();
			hash ^= keys_.GetHashCode();
			if (_unknownFields != null)
			{
				hash ^= _unknownFields.GetHashCode();
			}
			return hash;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override string ToString()
		{
			return pb::JsonFormatter.ToDiagnosticString(this);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void WriteTo(pb::CodedOutputStream output)
		{
			if (HasStartTimestamp)
			{
				output.WriteRawTag(9);
				output.WriteFixed64(StartTimestamp);
			}
			if (HasEndTimestamp)
			{
				output.WriteRawTag(17);
				output.WriteFixed64(EndTimestamp);
			}
			if (HasRegion)
			{
				output.WriteRawTag(26);
				output.WriteString(Region);
			}
			if (HasBatchNum)
			{
				output.WriteRawTag(32);
				output.WriteInt32(BatchNum);
			}
			if (HasBatchSize)
			{
				output.WriteRawTag(40);
				output.WriteInt32(BatchSize);
			}
			signatureInfos_.WriteTo(output, _repeated_signatureInfos_codec);
			keys_.WriteTo(output, _repeated_keys_codec);
			if (_unknownFields != null)
			{
				_unknownFields.WriteTo(output);
			}
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int CalculateSize()
		{
			int size = 0;
			if (HasStartTimestamp)
			{
				size += 1 + 8;
			}
			if (HasEndTimestamp)
			{
				size += 1 + 8;
			}
			if (HasRegion)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(Region);
			}
			if (HasBatchNum)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchNum);
			}
			if (HasBatchSize)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchSize);
			}
			size += signatureInfos_.CalculateSize(_repeated_signatureInfos_codec);
			size += keys_.CalculateSize(_repeated_keys_codec);
			if (_unknownFields != null)
			{
				size += _unknownFields.CalculateSize();
			}
			return size;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(TemporaryExposureKeyExport other)
		{
			if (other == null)
			{
				return;
			}
			if (other.HasStartTimestamp)
			{
				StartTimestamp = other.StartTimestamp;
			}
			if (other.HasEndTimestamp)
			{
				EndTimestamp = other.EndTimestamp;
			}
			if (other.HasRegion)
			{
				Region = other.Region;
			}
			if (other.HasBatchNum)
			{
				BatchNum = other.BatchNum;
			}
			if (other.HasBatchSize)
			{
				BatchSize = other.BatchSize;
			}
			signatureInfos_.Add(other.signatureInfos_);
			keys_.Add(other.keys_);
			_unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(pb::CodedInputStream input)
		{
			uint tag;
			while ((tag = input.ReadTag()) != 0)
			{
				switch (tag)
				{
					default:
						_unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
						break;
					case 9:
						{
							StartTimestamp = input.ReadFixed64();
							break;
						}
					case 17:
						{
							EndTimestamp = input.ReadFixed64();
							break;
						}
					case 26:
						{
							Region = input.ReadString();
							break;
						}
					case 32:
						{
							BatchNum = input.ReadInt32();
							break;
						}
					case 40:
						{
							BatchSize = input.ReadInt32();
							break;
						}
					case 50:
						{
							signatureInfos_.AddEntriesFrom(input, _repeated_signatureInfos_codec);
							break;
						}
					case 58:
						{
							keys_.AddEntriesFrom(input, _repeated_keys_codec);
							break;
						}
				}
			}
		}

	}

	public sealed partial class SignatureInfo : pb::IMessage<SignatureInfo>
	{
		private static readonly pb::MessageParser<SignatureInfo> _parser = new pb::MessageParser<SignatureInfo>(() => new SignatureInfo());
		private pb::UnknownFieldSet _unknownFields;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pb::MessageParser<SignatureInfo> Parser { get { return _parser; } }

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pbr::MessageDescriptor Descriptor
		{
			get { return global::Xamarin.ExposureNotifications.DefinitionsReflection.Descriptor.MessageTypes[1]; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		pbr::MessageDescriptor pb::IMessage.Descriptor
		{
			get { return Descriptor; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public SignatureInfo()
		{
			OnConstruction();
		}

		partial void OnConstruction();

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public SignatureInfo(SignatureInfo other) : this()
		{
			appBundleId_ = other.appBundleId_;
			androidPackage_ = other.androidPackage_;
			verificationKeyVersion_ = other.verificationKeyVersion_;
			verificationKeyId_ = other.verificationKeyId_;
			signatureAlgorithm_ = other.signatureAlgorithm_;
			_unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public SignatureInfo Clone()
		{
			return new SignatureInfo(this);
		}

		/// <summary>Field number for the "app_bundle_id" field.</summary>
		public const int AppBundleIdFieldNumber = 1;
		private readonly static string AppBundleIdDefaultValue = "";

		private string appBundleId_;
		/// <summary>
		/// Apple App Store Application Bundle ID
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string AppBundleId
		{
			get { return appBundleId_ ?? AppBundleIdDefaultValue; }
			set
			{
				appBundleId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "app_bundle_id" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasAppBundleId
		{
			get { return appBundleId_ != null; }
		}
		/// <summary>Clears the value of the "app_bundle_id" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearAppBundleId()
		{
			appBundleId_ = null;
		}

		/// <summary>Field number for the "android_package" field.</summary>
		public const int AndroidPackageFieldNumber = 2;
		private readonly static string AndroidPackageDefaultValue = "";

		private string androidPackage_;
		/// <summary>
		/// Android App package name
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string AndroidPackage
		{
			get { return androidPackage_ ?? AndroidPackageDefaultValue; }
			set
			{
				androidPackage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "android_package" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasAndroidPackage
		{
			get { return androidPackage_ != null; }
		}
		/// <summary>Clears the value of the "android_package" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearAndroidPackage()
		{
			androidPackage_ = null;
		}

		/// <summary>Field number for the "verification_key_version" field.</summary>
		public const int VerificationKeyVersionFieldNumber = 3;
		private readonly static string VerificationKeyVersionDefaultValue = "";

		private string verificationKeyVersion_;
		/// <summary>
		/// Key version for rollovers
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string VerificationKeyVersion
		{
			get { return verificationKeyVersion_ ?? VerificationKeyVersionDefaultValue; }
			set
			{
				verificationKeyVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "verification_key_version" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasVerificationKeyVersion
		{
			get { return verificationKeyVersion_ != null; }
		}
		/// <summary>Clears the value of the "verification_key_version" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearVerificationKeyVersion()
		{
			verificationKeyVersion_ = null;
		}

		/// <summary>Field number for the "verification_key_id" field.</summary>
		public const int VerificationKeyIdFieldNumber = 4;
		private readonly static string VerificationKeyIdDefaultValue = "";

		private string verificationKeyId_;
		/// <summary>
		/// Additional identifying information
		/// E.g., backend might serve app in different countries with different keys
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string VerificationKeyId
		{
			get { return verificationKeyId_ ?? VerificationKeyIdDefaultValue; }
			set
			{
				verificationKeyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "verification_key_id" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasVerificationKeyId
		{
			get { return verificationKeyId_ != null; }
		}
		/// <summary>Clears the value of the "verification_key_id" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearVerificationKeyId()
		{
			verificationKeyId_ = null;
		}

		/// <summary>Field number for the "signature_algorithm" field.</summary>
		public const int SignatureAlgorithmFieldNumber = 5;
		private readonly static string SignatureAlgorithmDefaultValue = "";

		private string signatureAlgorithm_;
		/// <summary>
		/// E.g. ECDSA using a p-256 curve and SHA-256 as a hash function
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public string SignatureAlgorithm
		{
			get { return signatureAlgorithm_ ?? SignatureAlgorithmDefaultValue; }
			set
			{
				signatureAlgorithm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "signature_algorithm" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasSignatureAlgorithm
		{
			get { return signatureAlgorithm_ != null; }
		}
		/// <summary>Clears the value of the "signature_algorithm" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearSignatureAlgorithm()
		{
			signatureAlgorithm_ = null;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override bool Equals(object other)
		{
			return Equals(other as SignatureInfo);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool Equals(SignatureInfo other)
		{
			if (ReferenceEquals(other, null))
			{
				return false;
			}
			if (ReferenceEquals(other, this))
			{
				return true;
			}
			if (AppBundleId != other.AppBundleId) return false;
			if (AndroidPackage != other.AndroidPackage) return false;
			if (VerificationKeyVersion != other.VerificationKeyVersion) return false;
			if (VerificationKeyId != other.VerificationKeyId) return false;
			if (SignatureAlgorithm != other.SignatureAlgorithm) return false;
			return Equals(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override int GetHashCode()
		{
			int hash = 1;
			if (HasAppBundleId) hash ^= AppBundleId.GetHashCode();
			if (HasAndroidPackage) hash ^= AndroidPackage.GetHashCode();
			if (HasVerificationKeyVersion) hash ^= VerificationKeyVersion.GetHashCode();
			if (HasVerificationKeyId) hash ^= VerificationKeyId.GetHashCode();
			if (HasSignatureAlgorithm) hash ^= SignatureAlgorithm.GetHashCode();
			if (_unknownFields != null)
			{
				hash ^= _unknownFields.GetHashCode();
			}
			return hash;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override string ToString()
		{
			return pb::JsonFormatter.ToDiagnosticString(this);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void WriteTo(pb::CodedOutputStream output)
		{
			if (HasAppBundleId)
			{
				output.WriteRawTag(10);
				output.WriteString(AppBundleId);
			}
			if (HasAndroidPackage)
			{
				output.WriteRawTag(18);
				output.WriteString(AndroidPackage);
			}
			if (HasVerificationKeyVersion)
			{
				output.WriteRawTag(26);
				output.WriteString(VerificationKeyVersion);
			}
			if (HasVerificationKeyId)
			{
				output.WriteRawTag(34);
				output.WriteString(VerificationKeyId);
			}
			if (HasSignatureAlgorithm)
			{
				output.WriteRawTag(42);
				output.WriteString(SignatureAlgorithm);
			}
			if (_unknownFields != null)
			{
				_unknownFields.WriteTo(output);
			}
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int CalculateSize()
		{
			int size = 0;
			if (HasAppBundleId)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(AppBundleId);
			}
			if (HasAndroidPackage)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(AndroidPackage);
			}
			if (HasVerificationKeyVersion)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(VerificationKeyVersion);
			}
			if (HasVerificationKeyId)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(VerificationKeyId);
			}
			if (HasSignatureAlgorithm)
			{
				size += 1 + pb::CodedOutputStream.ComputeStringSize(SignatureAlgorithm);
			}
			if (_unknownFields != null)
			{
				size += _unknownFields.CalculateSize();
			}
			return size;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(SignatureInfo other)
		{
			if (other == null)
			{
				return;
			}
			if (other.HasAppBundleId)
			{
				AppBundleId = other.AppBundleId;
			}
			if (other.HasAndroidPackage)
			{
				AndroidPackage = other.AndroidPackage;
			}
			if (other.HasVerificationKeyVersion)
			{
				VerificationKeyVersion = other.VerificationKeyVersion;
			}
			if (other.HasVerificationKeyId)
			{
				VerificationKeyId = other.VerificationKeyId;
			}
			if (other.HasSignatureAlgorithm)
			{
				SignatureAlgorithm = other.SignatureAlgorithm;
			}
			_unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(pb::CodedInputStream input)
		{
			uint tag;
			while ((tag = input.ReadTag()) != 0)
			{
				switch (tag)
				{
					default:
						_unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
						break;
					case 10:
						{
							AppBundleId = input.ReadString();
							break;
						}
					case 18:
						{
							AndroidPackage = input.ReadString();
							break;
						}
					case 26:
						{
							VerificationKeyVersion = input.ReadString();
							break;
						}
					case 34:
						{
							VerificationKeyId = input.ReadString();
							break;
						}
					case 42:
						{
							SignatureAlgorithm = input.ReadString();
							break;
						}
				}
			}
		}

	}

	public sealed partial class TemporaryExposureKey : pb::IMessage<TemporaryExposureKey>
	{
		private static readonly pb::MessageParser<TemporaryExposureKey> _parser = new pb::MessageParser<TemporaryExposureKey>(() => new TemporaryExposureKey());
		private pb::UnknownFieldSet _unknownFields;
		private int _hasBits0;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pb::MessageParser<TemporaryExposureKey> Parser { get { return _parser; } }

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pbr::MessageDescriptor Descriptor
		{
			get { return global::Xamarin.ExposureNotifications.DefinitionsReflection.Descriptor.MessageTypes[2]; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		pbr::MessageDescriptor pb::IMessage.Descriptor
		{
			get { return Descriptor; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKey()
		{
			OnConstruction();
		}

		partial void OnConstruction();

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKey(TemporaryExposureKey other) : this()
		{
			_hasBits0 = other._hasBits0;
			keyData_ = other.keyData_;
			transmissionRiskLevel_ = other.transmissionRiskLevel_;
			rollingStartIntervalNumber_ = other.rollingStartIntervalNumber_;
			rollingPeriod_ = other.rollingPeriod_;
			_unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TemporaryExposureKey Clone()
		{
			return new TemporaryExposureKey(this);
		}

		/// <summary>Field number for the "key_data" field.</summary>
		public const int KeyDataFieldNumber = 1;
		private readonly static pb::ByteString KeyDataDefaultValue = pb::ByteString.Empty;

		private pb::ByteString keyData_;
		/// <summary>
		/// Key of infected user
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public pb::ByteString KeyData
		{
			get { return keyData_ ?? KeyDataDefaultValue; }
			set
			{
				keyData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "key_data" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasKeyData
		{
			get { return keyData_ != null; }
		}
		/// <summary>Clears the value of the "key_data" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearKeyData()
		{
			keyData_ = null;
		}

		/// <summary>Field number for the "transmission_risk_level" field.</summary>
		public const int TransmissionRiskLevelFieldNumber = 2;
		private readonly static int TransmissionRiskLevelDefaultValue = 0;

		private int transmissionRiskLevel_;
		/// <summary>
		/// Varying risk associated with a key depending on diagnosis method
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int TransmissionRiskLevel
		{
			get { if ((_hasBits0 & 1) != 0) { return transmissionRiskLevel_; } else { return TransmissionRiskLevelDefaultValue; } }
			set
			{
				_hasBits0 |= 1;
				transmissionRiskLevel_ = value;
			}
		}
		/// <summary>Gets whether the "transmission_risk_level" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasTransmissionRiskLevel
		{
			get { return (_hasBits0 & 1) != 0; }
		}
		/// <summary>Clears the value of the "transmission_risk_level" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearTransmissionRiskLevel()
		{
			_hasBits0 &= ~1;
		}

		/// <summary>Field number for the "rolling_start_interval_number" field.</summary>
		public const int RollingStartIntervalNumberFieldNumber = 3;
		private readonly static int RollingStartIntervalNumberDefaultValue = 0;

		private int rollingStartIntervalNumber_;
		/// <summary>
		/// The interval number since epoch for which a key starts
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int RollingStartIntervalNumber
		{
			get { if ((_hasBits0 & 2) != 0) { return rollingStartIntervalNumber_; } else { return RollingStartIntervalNumberDefaultValue; } }
			set
			{
				_hasBits0 |= 2;
				rollingStartIntervalNumber_ = value;
			}
		}
		/// <summary>Gets whether the "rolling_start_interval_number" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasRollingStartIntervalNumber
		{
			get { return (_hasBits0 & 2) != 0; }
		}
		/// <summary>Clears the value of the "rolling_start_interval_number" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearRollingStartIntervalNumber()
		{
			_hasBits0 &= ~2;
		}

		/// <summary>Field number for the "rolling_period" field.</summary>
		public const int RollingPeriodFieldNumber = 4;
		private readonly static int RollingPeriodDefaultValue = 144;

		private int rollingPeriod_;
		/// <summary>
		/// Increments of 10 minutes describing how long a key is valid
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int RollingPeriod
		{
			get { if ((_hasBits0 & 4) != 0) { return rollingPeriod_; } else { return RollingPeriodDefaultValue; } }
			set
			{
				_hasBits0 |= 4;
				rollingPeriod_ = value;
			}
		}
		/// <summary>Gets whether the "rolling_period" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasRollingPeriod
		{
			get { return (_hasBits0 & 4) != 0; }
		}
		/// <summary>Clears the value of the "rolling_period" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearRollingPeriod()
		{
			_hasBits0 &= ~4;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override bool Equals(object other)
		{
			return Equals(other as TemporaryExposureKey);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool Equals(TemporaryExposureKey other)
		{
			if (ReferenceEquals(other, null))
			{
				return false;
			}
			if (ReferenceEquals(other, this))
			{
				return true;
			}
			if (KeyData != other.KeyData) return false;
			if (TransmissionRiskLevel != other.TransmissionRiskLevel) return false;
			if (RollingStartIntervalNumber != other.RollingStartIntervalNumber) return false;
			if (RollingPeriod != other.RollingPeriod) return false;
			return Equals(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override int GetHashCode()
		{
			int hash = 1;
			if (HasKeyData) hash ^= KeyData.GetHashCode();
			if (HasTransmissionRiskLevel) hash ^= TransmissionRiskLevel.GetHashCode();
			if (HasRollingStartIntervalNumber) hash ^= RollingStartIntervalNumber.GetHashCode();
			if (HasRollingPeriod) hash ^= RollingPeriod.GetHashCode();
			if (_unknownFields != null)
			{
				hash ^= _unknownFields.GetHashCode();
			}
			return hash;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override string ToString()
		{
			return pb::JsonFormatter.ToDiagnosticString(this);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void WriteTo(pb::CodedOutputStream output)
		{
			if (HasKeyData)
			{
				output.WriteRawTag(10);
				output.WriteBytes(KeyData);
			}
			if (HasTransmissionRiskLevel)
			{
				output.WriteRawTag(16);
				output.WriteInt32(TransmissionRiskLevel);
			}
			if (HasRollingStartIntervalNumber)
			{
				output.WriteRawTag(24);
				output.WriteInt32(RollingStartIntervalNumber);
			}
			if (HasRollingPeriod)
			{
				output.WriteRawTag(32);
				output.WriteInt32(RollingPeriod);
			}
			if (_unknownFields != null)
			{
				_unknownFields.WriteTo(output);
			}
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int CalculateSize()
		{
			int size = 0;
			if (HasKeyData)
			{
				size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyData);
			}
			if (HasTransmissionRiskLevel)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(TransmissionRiskLevel);
			}
			if (HasRollingStartIntervalNumber)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(RollingStartIntervalNumber);
			}
			if (HasRollingPeriod)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(RollingPeriod);
			}
			if (_unknownFields != null)
			{
				size += _unknownFields.CalculateSize();
			}
			return size;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(TemporaryExposureKey other)
		{
			if (other == null)
			{
				return;
			}
			if (other.HasKeyData)
			{
				KeyData = other.KeyData;
			}
			if (other.HasTransmissionRiskLevel)
			{
				TransmissionRiskLevel = other.TransmissionRiskLevel;
			}
			if (other.HasRollingStartIntervalNumber)
			{
				RollingStartIntervalNumber = other.RollingStartIntervalNumber;
			}
			if (other.HasRollingPeriod)
			{
				RollingPeriod = other.RollingPeriod;
			}
			_unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(pb::CodedInputStream input)
		{
			uint tag;
			while ((tag = input.ReadTag()) != 0)
			{
				switch (tag)
				{
					default:
						_unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
						break;
					case 10:
						{
							KeyData = input.ReadBytes();
							break;
						}
					case 16:
						{
							TransmissionRiskLevel = input.ReadInt32();
							break;
						}
					case 24:
						{
							RollingStartIntervalNumber = input.ReadInt32();
							break;
						}
					case 32:
						{
							RollingPeriod = input.ReadInt32();
							break;
						}
				}
			}
		}

	}

	public sealed partial class TEKSignatureList : pb::IMessage<TEKSignatureList>
	{
		private static readonly pb::MessageParser<TEKSignatureList> _parser = new pb::MessageParser<TEKSignatureList>(() => new TEKSignatureList());
		private pb::UnknownFieldSet _unknownFields;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pb::MessageParser<TEKSignatureList> Parser { get { return _parser; } }

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pbr::MessageDescriptor Descriptor
		{
			get { return global::Xamarin.ExposureNotifications.DefinitionsReflection.Descriptor.MessageTypes[3]; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		pbr::MessageDescriptor pb::IMessage.Descriptor
		{
			get { return Descriptor; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignatureList()
		{
			OnConstruction();
		}

		partial void OnConstruction();

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignatureList(TEKSignatureList other) : this()
		{
			signatures_ = other.signatures_.Clone();
			_unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignatureList Clone()
		{
			return new TEKSignatureList(this);
		}

		/// <summary>Field number for the "signatures" field.</summary>
		public const int SignaturesFieldNumber = 1;
		private static readonly pb::FieldCodec<global::Xamarin.ExposureNotifications.TEKSignature> _repeated_signatures_codec
			= pb::FieldCodec.ForMessage(10, global::Xamarin.ExposureNotifications.TEKSignature.Parser);
		private readonly pbc::RepeatedField<global::Xamarin.ExposureNotifications.TEKSignature> signatures_ = new pbc::RepeatedField<global::Xamarin.ExposureNotifications.TEKSignature>();
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public pbc::RepeatedField<global::Xamarin.ExposureNotifications.TEKSignature> Signatures
		{
			get { return signatures_; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override bool Equals(object other)
		{
			return Equals(other as TEKSignatureList);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool Equals(TEKSignatureList other)
		{
			if (ReferenceEquals(other, null))
			{
				return false;
			}
			if (ReferenceEquals(other, this))
			{
				return true;
			}
			if (!signatures_.Equals(other.signatures_)) return false;
			return Equals(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override int GetHashCode()
		{
			int hash = 1;
			hash ^= signatures_.GetHashCode();
			if (_unknownFields != null)
			{
				hash ^= _unknownFields.GetHashCode();
			}
			return hash;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override string ToString()
		{
			return pb::JsonFormatter.ToDiagnosticString(this);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void WriteTo(pb::CodedOutputStream output)
		{
			signatures_.WriteTo(output, _repeated_signatures_codec);
			if (_unknownFields != null)
			{
				_unknownFields.WriteTo(output);
			}
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int CalculateSize()
		{
			int size = 0;
			size += signatures_.CalculateSize(_repeated_signatures_codec);
			if (_unknownFields != null)
			{
				size += _unknownFields.CalculateSize();
			}
			return size;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(TEKSignatureList other)
		{
			if (other == null)
			{
				return;
			}
			signatures_.Add(other.signatures_);
			_unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(pb::CodedInputStream input)
		{
			uint tag;
			while ((tag = input.ReadTag()) != 0)
			{
				switch (tag)
				{
					default:
						_unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
						break;
					case 10:
						{
							signatures_.AddEntriesFrom(input, _repeated_signatures_codec);
							break;
						}
				}
			}
		}

	}

	public sealed partial class TEKSignature : pb::IMessage<TEKSignature>
	{
		private static readonly pb::MessageParser<TEKSignature> _parser = new pb::MessageParser<TEKSignature>(() => new TEKSignature());
		private pb::UnknownFieldSet _unknownFields;
		private int _hasBits0;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pb::MessageParser<TEKSignature> Parser { get { return _parser; } }

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static pbr::MessageDescriptor Descriptor
		{
			get { return global::Xamarin.ExposureNotifications.DefinitionsReflection.Descriptor.MessageTypes[4]; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		pbr::MessageDescriptor pb::IMessage.Descriptor
		{
			get { return Descriptor; }
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignature()
		{
			OnConstruction();
		}

		partial void OnConstruction();

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignature(TEKSignature other) : this()
		{
			_hasBits0 = other._hasBits0;
			signatureInfo_ = other.HasSignatureInfo ? other.signatureInfo_.Clone() : null;
			batchNum_ = other.batchNum_;
			batchSize_ = other.batchSize_;
			signature_ = other.signature_;
			_unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public TEKSignature Clone()
		{
			return new TEKSignature(this);
		}

		/// <summary>Field number for the "signature_info" field.</summary>
		public const int SignatureInfoFieldNumber = 1;
		private global::Xamarin.ExposureNotifications.SignatureInfo signatureInfo_;
		/// <summary>
		/// Info about the signing key, version, algorithm, etc
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public global::Xamarin.ExposureNotifications.SignatureInfo SignatureInfo
		{
			get { return signatureInfo_; }
			set
			{
				signatureInfo_ = value;
			}
		}
		/// <summary>Gets whether the signature_info field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasSignatureInfo
		{
			get { return signatureInfo_ != null; }
		}
		/// <summary>Clears the value of the signature_info field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearSignatureInfo()
		{
			signatureInfo_ = null;
		}

		/// <summary>Field number for the "batch_num" field.</summary>
		public const int BatchNumFieldNumber = 2;
		private readonly static int BatchNumDefaultValue = 0;

		private int batchNum_;
		/// <summary>
		/// E.g., File 2 in batch size of 10. Ordinal, 1-based numbering.
		/// E.g., Batch 2 of 10
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int BatchNum
		{
			get { if ((_hasBits0 & 1) != 0) { return batchNum_; } else { return BatchNumDefaultValue; } }
			set
			{
				_hasBits0 |= 1;
				batchNum_ = value;
			}
		}
		/// <summary>Gets whether the "batch_num" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasBatchNum
		{
			get { return (_hasBits0 & 1) != 0; }
		}
		/// <summary>Clears the value of the "batch_num" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearBatchNum()
		{
			_hasBits0 &= ~1;
		}

		/// <summary>Field number for the "batch_size" field.</summary>
		public const int BatchSizeFieldNumber = 3;
		private readonly static int BatchSizeDefaultValue = 0;

		private int batchSize_;
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int BatchSize
		{
			get { if ((_hasBits0 & 2) != 0) { return batchSize_; } else { return BatchSizeDefaultValue; } }
			set
			{
				_hasBits0 |= 2;
				batchSize_ = value;
			}
		}
		/// <summary>Gets whether the "batch_size" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasBatchSize
		{
			get { return (_hasBits0 & 2) != 0; }
		}
		/// <summary>Clears the value of the "batch_size" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearBatchSize()
		{
			_hasBits0 &= ~2;
		}

		/// <summary>Field number for the "signature" field.</summary>
		public const int SignatureFieldNumber = 4;
		private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

		private pb::ByteString signature_;
		/// <summary>
		/// Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
		/// </summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public pb::ByteString Signature
		{
			get { return signature_ ?? SignatureDefaultValue; }
			set
			{
				signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
			}
		}
		/// <summary>Gets whether the "signature" field is set</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool HasSignature
		{
			get { return signature_ != null; }
		}
		/// <summary>Clears the value of the "signature" field</summary>
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void ClearSignature()
		{
			signature_ = null;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override bool Equals(object other)
		{
			return Equals(other as TEKSignature);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public bool Equals(TEKSignature other)
		{
			if (ReferenceEquals(other, null))
			{
				return false;
			}
			if (ReferenceEquals(other, this))
			{
				return true;
			}
			if (!object.Equals(SignatureInfo, other.SignatureInfo)) return false;
			if (BatchNum != other.BatchNum) return false;
			if (BatchSize != other.BatchSize) return false;
			if (Signature != other.Signature) return false;
			return Equals(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override int GetHashCode()
		{
			int hash = 1;
			if (HasSignatureInfo) hash ^= SignatureInfo.GetHashCode();
			if (HasBatchNum) hash ^= BatchNum.GetHashCode();
			if (HasBatchSize) hash ^= BatchSize.GetHashCode();
			if (HasSignature) hash ^= Signature.GetHashCode();
			if (_unknownFields != null)
			{
				hash ^= _unknownFields.GetHashCode();
			}
			return hash;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public override string ToString()
		{
			return pb::JsonFormatter.ToDiagnosticString(this);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void WriteTo(pb::CodedOutputStream output)
		{
			if (HasSignatureInfo)
			{
				output.WriteRawTag(10);
				output.WriteMessage(SignatureInfo);
			}
			if (HasBatchNum)
			{
				output.WriteRawTag(16);
				output.WriteInt32(BatchNum);
			}
			if (HasBatchSize)
			{
				output.WriteRawTag(24);
				output.WriteInt32(BatchSize);
			}
			if (HasSignature)
			{
				output.WriteRawTag(34);
				output.WriteBytes(Signature);
			}
			if (_unknownFields != null)
			{
				_unknownFields.WriteTo(output);
			}
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public int CalculateSize()
		{
			int size = 0;
			if (HasSignatureInfo)
			{
				size += 1 + pb::CodedOutputStream.ComputeMessageSize(SignatureInfo);
			}
			if (HasBatchNum)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchNum);
			}
			if (HasBatchSize)
			{
				size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchSize);
			}
			if (HasSignature)
			{
				size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
			}
			if (_unknownFields != null)
			{
				size += _unknownFields.CalculateSize();
			}
			return size;
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(TEKSignature other)
		{
			if (other == null)
			{
				return;
			}
			if (other.HasSignatureInfo)
			{
				if (!HasSignatureInfo)
				{
					SignatureInfo = new global::Xamarin.ExposureNotifications.SignatureInfo();
				}
				SignatureInfo.MergeFrom(other.SignatureInfo);
			}
			if (other.HasBatchNum)
			{
				BatchNum = other.BatchNum;
			}
			if (other.HasBatchSize)
			{
				BatchSize = other.BatchSize;
			}
			if (other.HasSignature)
			{
				Signature = other.Signature;
			}
			_unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
		}

		[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
		public void MergeFrom(pb::CodedInputStream input)
		{
			uint tag;
			while ((tag = input.ReadTag()) != 0)
			{
				switch (tag)
				{
					default:
						_unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
						break;
					case 10:
						{
							if (!HasSignatureInfo)
							{
								SignatureInfo = new global::Xamarin.ExposureNotifications.SignatureInfo();
							}
							input.ReadMessage(SignatureInfo);
							break;
						}
					case 16:
						{
							BatchNum = input.ReadInt32();
							break;
						}
					case 24:
						{
							BatchSize = input.ReadInt32();
							break;
						}
					case 34:
						{
							Signature = input.ReadBytes();
							break;
						}
				}
			}
		}

	}

	#endregion

}

#endregion Designer generated code
